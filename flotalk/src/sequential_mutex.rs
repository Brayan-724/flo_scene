use crate::continuation::*;
use crate::error::*;

use futures::channel::oneshot;

use std::collections::{VecDeque};

///
/// A sequential mutex supplies a value via a `TalkContinuation`. Values are returned in the order
/// that they're requested. This is typically used with an allocator as a storage cell, and works like
/// a mutex that can acquire the value over several continuations.
///
/// Note that unlike a mutex, the value must be manually returned to its storage container when it has
/// been finished with.
///
pub struct TalkSequentialMutex<TValue>
where
    TValue: 'static + Send,
{
    /// The value when it hasn't been borrowed by a continuation
    value_at_rest: Option<TValue>,

    /// Other futures that are waiting for the value from this mutex (or None if this has never been used before)
    waiting_values: Option<Box<VecDeque<oneshot::Sender<TValue>>>>,
}


impl<TValue> TalkSequentialMutex<TValue>
where
    TValue: 'static + Send
{
    ///
    /// Stores a value in a sequential mutex
    ///
    pub fn new(value: TValue) -> TalkSequentialMutex<TValue> {
        TalkSequentialMutex {
            value_at_rest:  Some(value),
            waiting_values: None,
        }
    }

    ///
    /// Returns a continuation that will acquire the value and then continue with the specified function
    ///
    /// The continuation is expected to eventually return the value with the `give()` function.
    ///
    pub fn take(&mut self, when_available: impl 'static + Send + FnOnce(TValue) -> TalkContinuation<'static>) -> TalkContinuation<'static> {
        if let Some(value) = self.value_at_rest.take() {
            // If the value is available, then invoke the function immediately and return the resulting continuation
            when_available(value)
        } else {
            // If the value is not available, create a channel to send it when it's returned to this object
            let (send, recv) = oneshot::channel();

            self.waiting_values.get_or_insert_with(|| Box::new(VecDeque::new())).push_back(send);

            // Continuation waits for the value to be returned before calling when_available
            TalkContinuation::future_soon(async move {
                let mut recv    = recv;
                let value       = recv.await;

                if let Ok(value) = value {
                    when_available(value)
                } else {
                    TalkContinuation::from(TalkError::ObjectValueLost)
                }
            })
        }
    }

    ///
    /// Returns a value to this object, once the continuation generated by `take()` is finished with it
    ///
    pub fn give(&mut self, returning_value: TValue) {
        if let Some(waiting_values) = &mut self.waiting_values {
            let mut returning_value = returning_value;

            while let Some(sender) = waiting_values.pop_front() {
                // Try to send the value to the next continuation
                if let Err(failed_value) = sender.send(returning_value) {
                    // Continuation doesn't exist any more
                    returning_value = failed_value;
                } else {
                    // Value has been passed on (or lost)
                    return;
                }
            }

            // Nothing remaining is waiting on this mutex
            self.value_at_rest = Some(returning_value);
        } else {
            // Nothing has ever blocked on this mutex
            self.value_at_rest = Some(returning_value);
        }
    }
}
