use flo_scene::*;

use tokio::io::{AsyncRead, AsyncWrite, ReadBuf};
use futures::prelude::*;
use futures::stream::{BoxStream, ReadyChunks};

use std::pin::{Pin};
use std::result::{Result};
use std::task::{Context, Poll};

///
/// Requests that can be made to the internal socket program
///
pub enum InternalSocketMessage {
    ///
    /// Subscribes to connection requests for an internal socket program
    ///
    Subscribe,

    ///
    /// Creates an internal socket connection
    ///
    CreateInternalSocket(Box<dyn Send + AsyncRead>, Box<dyn Send + AsyncWrite>),
}

impl SceneMessage for InternalSocketMessage { }

///
/// The stream reader is used to convert an input stream of bytes into an AsyncRead implementation
///
struct StreamReader<TSourceStream> {
    source:     Option<Pin<Box<TSourceStream>>>,
    pending:    Vec<u8>,
}

impl<TSourceStream> AsyncRead for StreamReader<ReadyChunks<TSourceStream>>
where
    TSourceStream: Stream<Item=u8>,
{
    fn poll_read(
        mut self:   Pin<&mut Self>,
        cx:         &mut Context<'_>,
        buf:        &mut ReadBuf<'_>,
    ) -> Poll<std::io::Result<()>> {
        loop {
            // If 0 bytes are read but 'OK' is returned, we keep trying to read until the source blocks (as otherwise we'll get stuck)
            if self.pending.is_empty() {
                // If pending is empty we've got no bytes to return: try to read from teh source stream
                if let Some(source) = self.source.as_mut() {
                    // Poll for data from the source stream
                    match ReadyChunks::<TSourceStream>::poll_next(source.as_mut(), cx) {
                        Poll::Pending => {
                            // No more bytes to read at the moment
                            break Poll::Pending;
                        }

                        Poll::Ready(None) => {
                            // EOF, nothing more to read (disconnect from the source stream at this point)
                            self.source = None;
                            break Poll::Ready(Ok(()));
                        }

                        Poll::Ready(Some(new_bytes)) => {
                            // Add the bytes that we read to the internal buffer
                            self.pending.extend(new_bytes);
                        }
                    }
                } else {
                    // EOF has been hit before
                    break Poll::Ready(Ok(()));
                }
            }

            if !self.pending.is_empty() {
                // Read from the pending buffer into the read buffer
                let to_copy = self.pending.len().min(buf.remaining());

                // Write the bytes to the output buffer
                buf.put_slice(&self.pending[0..to_copy]);
                self.pending.splice(0..to_copy, []);

                // Some bytes were read into the pending or the read buffer
                break Poll::Ready(Ok(()));
            }
        }
    }
}

///
/// The stream writer converts an output sink of bytes into an AsyncWrite implementation
///
struct StreamWriter<TTargetSink> {
    target:         TTargetSink,
    max_pending:    usize,
    pending:        Vec<u8>,
}

impl<TTargetSink> AsyncWrite for StreamWriter<TTargetSink>
where
    TTargetSink: Sink<u8>,
{
    fn poll_write(
        self: Pin<&mut Self>,
        cx: &mut Context<'_>,
        buf: &[u8],
    ) -> Poll<Result<usize, std::io::Error>> {
        todo!()
    }

    fn poll_flush(self: std::pin::Pin<&mut Self>, cx: &mut std::task::Context<'_>) -> std::task::Poll<Result<(), std::io::Error>> {
        todo!()
    }

    fn poll_shutdown(self: std::pin::Pin<&mut Self>, cx: &mut std::task::Context<'_>) -> std::task::Poll<Result<(), std::io::Error>> {
        todo!()
    }
}

impl InternalSocketMessage {
    ///
    /// Returns a 'CreateInternalSocket' request which will send the messages generated by an input stream of bytes and receive the messages
    /// sent by an output stream of bytes
    ///
    pub fn create_socket_from_streams(input: impl 'static + Send + Stream<Item=u8>, output: impl 'static + Send + Sink<u8>) -> InternalSocketMessage {
        let input_stream    = StreamReader { source: Some(Box::pin(input.ready_chunks(256))), pending: Vec::with_capacity(256) };
        let output_stream   = StreamWriter { target: output, max_pending: 256, pending: Vec::with_capacity(256) };

        InternalSocketMessage::CreateInternalSocket(Box::new(input_stream), Box::new(output_stream))
    }
}

///
/// Creates an internal socket program
///
pub fn start_internal_socket_program<TInputStream, TOutputMessage>(
    scene:                  &Scene, 
    program_id:             SubProgramId, 
    create_input_messages:  impl 'static + Send + Sync + Fn(BoxStream<'static, Vec<u8>>) -> TInputStream, 
    create_output_messages: impl 'static + Send + Sync + Fn(BoxStream<'static, TOutputMessage>) -> BoxStream<'static, Vec<u8>>
) -> Result<(), ConnectionError> 
where
    TInputStream:   'static + Send + Stream,
    TOutputMessage: 'static + Send,
{
    Ok(())
}

#[cfg(test)]
mod test {
    use super::*;
    use futures::executor;
    use tokio::io::{AsyncReadExt};

    #[test]
    fn stream_reader_read() {
        let input_stream    = vec![0u8, 1u8, 2u8, 3u8, 4u8, 5u8, 6u8];
        let input_stream    = stream::iter(input_stream.into_iter());
        let stream_reader   = StreamReader { source: Some(Box::pin(input_stream.ready_chunks(256))), pending: vec![] };

        let read_bytes = executor::block_on(async {
            let mut stream_reader   = stream_reader;
            let mut result          = vec![];
            let mut buf             = [0u8, 0u8];

            while let Ok(num_read) = stream_reader.read(&mut buf).await {
                if num_read == 0 { break; }

                result.extend(buf[0..num_read].iter().copied());
            }

            result
        });

        assert!(read_bytes == vec![0u8, 1u8, 2u8, 3u8, 4u8, 5u8, 6u8], "{:?}", read_bytes);
    }
}